<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="theme" content="Chirpy v2.5.1"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Writing a GHIDRA Loader: STM32 Edition." /><meta name="author" content="wrongbaud" /><meta property="og:locale" content="en_US" /><meta name="description" content="A blog focusing on hardware and software reverse engineering" /><meta property="og:description" content="A blog focusing on hardware and software reverse engineering" /><link rel="canonical" href="https://wrongbaud.github.io/posts/writing-a-ghidra-loader/" /><meta property="og:url" content="https://wrongbaud.github.io/posts/writing-a-ghidra-loader/" /><meta property="og:site_name" content="Wrongbaud’s Blog" /><meta property="og:image" content="https://wrongbaud.github.io/" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-02-21T08:22:10+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://wrongbaud.github.io/" /><meta property="twitter:title" content="Writing a GHIDRA Loader: STM32 Edition." /><meta name="twitter:site" content="@wrongbaud" /><meta name="twitter:creator" content="@wrongbaud" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"A blog focusing on hardware and software reverse engineering","headline":"Writing a GHIDRA Loader: STM32 Edition.","dateModified":"2020-02-21T08:22:10+08:00","datePublished":"2020-02-21T08:22:10+08:00","@type":"BlogPosting","image":"https://wrongbaud.github.io/","url":"https://wrongbaud.github.io/posts/writing-a-ghidra-loader/","mainEntityOfPage":{"@type":"WebPage","@id":"https://wrongbaud.github.io/posts/writing-a-ghidra-loader/"},"author":{"@type":"Person","name":"wrongbaud"},"@context":"https://schema.org"}</script><title>Writing a GHIDRA Loader: STM32 Edition. | Wrongbaud's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="/assets/js/post.min.js"></script> <script defer src="/app.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/" alt="avatar"> <img src="https://i2.wp.com/wasistdas.co.uk/Owlsploitation/wp-content/uploads/2011/05/bubo2.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">Wrongbaud's Blog</a></div><div class="site-subtitle font-italic">Hardware / Software Reverse Engineering</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/wrongbaud" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/wrongbaud" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['wrongbaud','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Writing a GHIDRA Loader: STM32 Edition.</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Writing a GHIDRA Loader: STM32 Edition.</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Feb 21, 2020, 8:22 AM +0800" > Feb 21, 2020 <i class="unloaded">2020-02-21T08:22:10+08:00</i> </span> by <span class="author"> wrongbaud </span></div><div> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Nov 23, 2020, 7:40 AM -0500" > Nov 23, 2020 <i class="unloaded">2020-11-23T20:40:52+08:00</i> </span></div></div><div class="post-content"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="" class="post-preview-img"><h1 id="background">Background</h1><p>In my <a href="https://wrongbaud.github.io/posts/stm-xbox-jtag/">last post</a>, we managed to dump the firmware off of an Xbox One controller by using the Single Wire Debug interface. Now that we have the firmware image as well as the target CPU determined, we can load it into Ghidra and attempt to learn more about how it works. For this post, we are focusing on learning more about how the firmware image works by writing a proper Ghidra loader and reviewing the USB stack.</p><h4 id="required-reading--materials">Required Reading / Materials</h4><p>If you’ve not read my <a href="https://wrongbaud.github.io/posts/stm-xbox-jtag/">last post</a> on SWD and OpenOCD, you want to start there; you also need the <a href="https://www.st.com/content/ccc/resource/technical/document/reference_manual/51/f7/f3/06/cd/b6/46/ec/CD00225773.pdf/files/CD00225773.pdf/jcr:content/translations/en.CD00225773.pdf">datasheet</a> for the target CPU family.</p><h2 id="what-is-ghidra">What is Ghidra?</h2><p><a href="https://ghidra-sre.org/">Ghidra</a> is a SRE (software reverse engineering) suite of tools developed by NSA. If you are familiar with IDA-Pro, r2, or Binary Ninja, you are already likely familiar with Ghidra. We can use any of the tools mentioned above to reverse engineer this firmware image. Still, I am choosing Ghidra as it is open source (not unlike r2) and has a <a href="https://thecyberwire.com/stories/Mike-Bell-Extending-Ghidra-from-Script-to-Plugins-and-Beyond.html">relatively robust and well-documented API for scripting and analyzing binaries</a>. Ghidra is also growing with contributions from the community (most notably for me was the addition of the Infineon Tricore architecture to the list of supported CPUs) I have covered utilizing ghidra in <a href="https://wrongbaud.github.io/posts/hightec-tricore-linux-ghidra/">previous posts</a> as well and it is quickly becoming my reverse engineering tool of choice.</p><h2 id="loading-the-controller-firmware-in-ghidra">Loading the Controller Firmware in Ghidra</h2><p>First off, if you don’t have Ghidra, you can always grab the latest version from <a href="https://ghidra-sre.org/">here</a> or <a href="https://github.com/dukebarman/ghidra-builder">build it yourself</a>, for this post I am using <code class="language-plaintext highlighter-rouge">9.1.2_PUBLIC</code> release from the official site. We’ll start by opening the CodeBrowser window by clicking on the green dragon button.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://wrongbaud.github.io/assets/img/ghidra-loader/ghdra-project-window.png" alt="Ghidra Broswer" /></p><p>After selecting this, you’ll see the following window open up; this is the CodeBrowser</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://wrongbaud.github.io/assets/img/ghidra-loader/codebrowser.png" alt="Code Browser" /></p><p>Next, we import the dumped firmware image by pressing <code class="language-plaintext highlighter-rouge">I</code> or going to <code class="language-plaintext highlighter-rouge">File</code> -&gt; <code class="language-plaintext highlighter-rouge">Import File</code> which causes the following window to appear:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://wrongbaud.github.io/assets/img/ghidra-loader/import.png" alt="Import" /></p><p>For language, select Cortex (Little Endian), which is what is in the <a href="https://www.st.com/content/ccc/resource/technical/document/reference_manual/51/f7/f3/06/cd/b6/46/ec/CD00225773.pdf/files/CD00225773.pdf/jcr:content/translations/en.CD00225773.pdf">datasheet</a> for this chip. Under options, we set the load address to <code class="language-plaintext highlighter-rouge">0x8000000</code>, which is the appropriate load address for these CPUs according to the datasheet.</p><p>Since this is a rather small firmware image, Ghidra’s auto-analysis handles a <em>lot</em> for us. For example, the USB descriptor strings are assigned XREFs from the start. For those that are unfamiliar, n <code class="language-plaintext highlighter-rouge">XREF</code> (cross-reference) is generated when the disassembler detects an address being used by an instruction.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://wrongbaud.github.io/assets/img/ghidra-loader/xrefs.png" alt="XREFs" /></p><p>While this is useful, there are still regions of memory that we haven’t yet defined in Ghidra. These are noted by the red values.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://wrongbaud.github.io/assets/img/ghidra-loader/undefined-regions.png" alt="XREFs" /></p><p>So what are these exactly? These are regions in memory that Ghidra can detect are being used, but are not defined in our Ghidra database. Remember that we are not reverse engineering a standard executable, which would typically reside in virtual memory whose expected ranges are defined in the header (ELF, PE.). This firmware image interacts with various hardware peripherals as memory-mapped IO. In order to make reversing this firmware image a little easier, we can define the memory ranges in Ghidra. This can be done manually, via a script, or through a loader. Since I often run into STM32 variants through my reverse engineering projects, I think it is worth the time to write a simple loader for the STM32F2 series and learn more about extending Ghidra.</p><h4 id="what-is-a-ghidra-loader">What is a Ghidra Loader?</h4><p>A Ghidra loader is an extension that makes the loading of a binary file more streamlined. For example, if the binary file has a header defining various memory regions and features, the loader can read those features and add the necessary sections to your Ghidra database to assist with the reverse engineering process. For our target, the loader sets up the appropriate memory-mapped peripherals and labeling registers of interest to streamline the process of reverse-engineering the USB stack on this controller.</p><h2 id="writing-a-loader">Writing a Loader</h2><p>Ghidra has an extension for Eclipse that makes debugging Loaders and scripts reasonably simple, start by downloading and installing the latest version of Eclipse from <a href="https://www.eclipse.org/downloads/">here</a>. Once you have Eclipse installed and set up, the Ghidra development extension can be installed by following the instructions located at <code class="language-plaintext highlighter-rouge">ghidra_9.1.2_PUBLIC/Extensions/Eclipse/GhidraDev/GhidraDev_README.html</code>. With this installed, open Eclipse and go to <code class="language-plaintext highlighter-rouge">GhidraDev</code> -&gt; <code class="language-plaintext highlighter-rouge">New</code> -&gt; <code class="language-plaintext highlighter-rouge">Ghidra Module Project</code> provide a project name and select <code class="language-plaintext highlighter-rouge">Loader</code>.</p><p>With our loader, we want to perform the following:</p><ol><li>Create and label memory ranges for memory-mapped peripherals<li>Find and label entry point and IVT<li>Label Locations of Interest</ol><h4 id="ghidra-loader-components">Ghidra Loader Components</h4><p>When starting with the baseline project, we are given the following function definitions:</p><ul><li><code class="language-plaintext highlighter-rouge">getName</code></ul><p>This one is fairly self-explanatory, we need not get into it.</p><ul><li><code class="language-plaintext highlighter-rouge">findSupportedLoadSpecs</code></ul><p>This function is used to determine if your loader can load the binary or not. In this function, you would check the header for your target if it has a known format. For our case with this flat firmware image, there isn’t much we can do here. We do have to set the Language/Compiler pair here, however, which is done with the following line:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>loadSpecs.add(new LoadSpec(this, 0, new LanguageCompilerSpecPair("ARM:LE:32:Cortex", "default"), true));
</pre></table></code></div></div><p>Here we are telling Ghidra to use the ARM Cortex LE analyzer.</p><ul><li><code class="language-plaintext highlighter-rouge">load</code></ul><p>Here we load the actual bytes into the program. In this function we perform the bulk of our <em>loading</em>, we set up our memory map, create any labels, and map the binary data from the <code class="language-plaintext highlighter-rouge">ByteProvider</code> object into memory via its <code class="language-plaintext highlighter-rouge">InputStream</code></p><ul><li><code class="language-plaintext highlighter-rouge">getDefaultOptions</code></ul><p>This function allows you to add custom options to your loader if needed. In our case, we do not need to add any additional options.</p><ul><li><code class="language-plaintext highlighter-rouge">validateOptions</code></ul><p>Here you can check the custom options to ensure that they make sense, again we aren’t using this for our loader.</p><h4 id="step-1-create-the-memory-map">Step 1: Create the Memory Map</h4><p>The first thing we want to do with this loader is to generate an appropriate memory map. To do this, we consult the diagram on page 51 of the datasheet. Given that there are so many, we can create a class for each region, as seen below:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>        private static class STM32MemRegion {
                String name;
                int addr;
                int size;
                boolean read;
                boolean write;
                boolean execute;
                private STM32MemRegion(String name, int addr, int size, boolean read, boolean write, boolean execute) {
                        this.name = name;
                        this.addr = addr;
                        this.size = size;
                        this.read = read;
                        this.write = write;
                        this.execute = execute;
                }
        }
</pre></table></code></div></div><p>This way, a region can be defined as shown below:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>new STM32MemRegion("TIM2",0x40000000,0x3FF,true,true,false)
</pre></table></code></div></div><p>With this defined, we can create an array memory regions, and then use the following Ghidra API call to create the necessary memory regions in our database:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>createUninitializedBlock(memregion.name, api.toAddr(memregion.addr), memregion.size, false);
</pre></table></code></div></div><p>The full loop to create these regions is below:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre>        FlatProgramAPI api = new FlatProgramAPI(program,monitor);
                InputStream inStream = provider.getInputStream(0);
                Memory mem = program.getMemory();
                // TODO: Load the bytes from 'provider' into the 'program'.
                // This is where we actually "Load" the program into ghidra

                // First we loop through our memory map that we created:
                for(STM32MemRegion memregion: STM32MEM) {
                        try {
                                mem.createUninitializedBlock(memregion.name, api.toAddr(memregion.addr), memregion.size, false);
                        } catch (LockException e) {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                        } catch (DuplicateNameException e) {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                        } catch (MemoryConflictException e) {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                        } catch (AddressOverflowException e) {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                        }
                }
                try {
                        mem.createInitializedBlock("Main Memory", api.toAddr(0x8000000), inStream, 0xFFFFF, monitor, false);
                } catch (LockException | MemoryConflictException | AddressOverflowException | CancelledException
                                | DuplicateNameException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
</pre></table></code></div></div><p>And with this, we have mapped out all of the memory-mapped peripherals!</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://wrongbaud.github.io/assets/img/ghidra-loader/mem-regions.png" alt="Memory Maps" /></p><p><strong>Disclaimer:</strong> If there is a better way to do this with the Ghidra API, please let me know or even better submit a PR. One of my favorite things about this blog is getting constructive feedback and recommendations from people.</p><h4 id="step-2-create-and-label-entry-point--ivt">Step 2: Create and Label Entry Point / IVT</h4><p>When looking at the datasheet, we can see that the processor maps a memory region to the start address (<code class="language-plaintext highlighter-rouge">0x00000000</code>) based on the boot mode. From here, the first entry is the start of the stack address, and the next entry is the reset vector. Following these entries should also be the interrupt vector table.</p><p>With our image, it appears to be mapping the flash region <code class="language-plaintext highlighter-rouge">0x8000000</code> at <code class="language-plaintext highlighter-rouge">0</code> on boot, meaning that our first DWORD will be the stack size, and the next will be the start address. We can read the data for both of these entries and create relevant labels with the code snippet below:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>// Top of stack is first value in memory, see page 59 of datasheet
// Make pointer, label it as stack start
int stackAddr = mem.getInt(api.toAddr(0x8000000));
Data stackAddrData = api.createDWord(api.toAddr(0x8000000));
api.createLabel(api.toAddr(stackAddr),"_STACK_BEGIN",true);
api.createMemoryReference(stackAddrData, api.toAddr(stackAddr), ghidra.program.model.symbol.RefType.DATA);

// Mark the entry point of the binary, also referenced in the datasheet on page 59
int entryPoint = mem.getInt(api.toAddr(0x8000004));
Data entryPointData = api.createDWord(api.toAddr(0x8000004));
api.createDWord(api.toAddr(0x8000004));
api.createLabel(api.toAddr(entryPoint),"_ENTRY_POINT",true);
api.createMemoryReference(entryPointData, api.toAddr(entryPoint), ghidra.program.model.symbol.RefType.DATA);
</pre></table></code></div></div><p>So with this, we can read the initial entries and label them properly with the values from the datasheet on page 59. There are quite a few entries here, so we do the same thing with the IVT that we did with the memory regions, starting with the following class:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>        private static class STM32InterruptVector{
                String name;
                int addr;
                private STM32InterruptVector(String name, int addr)
                {
                        this.name = name;
                        this.addr = addr;
                }
        }

</pre></table></code></div></div><p>So with this, we can create another list of IVT entries and loop over them during the loading process. The loop can be seen below:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>    for(STM32InterruptVector vector: STM32IVT) {
        int ptrVal = mem.getInt(api.toAddr(0x8000000+vector.addr));
        try {
        Data ptrData = api.createDWord(api.toAddr(0x8000000+vector.addr));
        api.createDWord(api.toAddr(0x8000000+vector.addr));
        api.createLabel(api.toAddr(0x8000000+vector.addr),vector.name,true);
        api.createMemoryReference(ptrData, api.toAddr(ptrVal), ghidra.program.model.symbol.RefType.DATA);
        } catch(ghidra.util.exception.InvalidInputException e) {
            // This is ugly, need to fix
            continue;
        }
    }
} catch (Exception e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
}
</pre></table></code></div></div><p>After adding this, the start of our image now looks like this in Ghidra:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://wrongbaud.github.io/assets/img/ghidra-loader/vectors.png" alt="Vectors" /></p><h4 id="step-3-label-locations-of-interest">Step 3: Label Locations of Interest</h4><p>So we want to outline more of the USB functionality in this firmware image, to make things a little more readable, we can label the USB configuration registers. To do this, we do the same thing that we did with the other regions/registers.</p><p>To create these, we use a similar technique to the other regions that we identified, except for this time, we only create labels. You can look at the <a href="https://github.com/wrongbaud/ghidra-stm32">github project for specific details</a>, but the addition of the control registers cleans up the assembly quite nicely.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://wrongbaud.github.io/assets/img/ghidra-loader/usbregs.png" alt="USB Annotation" /></p><h4 id="closing-thoughts-on-loader-development">Closing Thoughts on Loader Development</h4><p>Writing this Ghidra loader was a beneficial exercise for me because I often end up looking at strange embedded firmware images similar to this one.</p><p>If you are wondering why I created classes for each type of region or feature that we added to the ghidra database, I can explain. I end up manually generating memory maps fairly frequently and plan on building a generic loader that loads regions, register labels, and other useful things from a JSON file on startup. I spent far too much time manually entering these regions and creating labels for various esoteric CPUs and wanted to use the STM32 as a learning ground for what it would take to write a loader. After writing this preliminary loader, I think it is feasible to write a generic loader that loads the various memory segments, register labels and other things from a JSON file, but that is for another night!</p><h2 id="analysis">Analysis</h2><p>With the new loader, interesting information falls out of subroutines that would otherwise take more time to reverse engineer, take the following example:</p><p>Before loader:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://wrongbaud.github.io/assets/img/ghidra-loader/pre-loader.png" alt="USB Annotation" /></p><p>At a glance, it’s hard to determine what this subroutine might be doing. It is accessing memory regions that are not defined, and it’s hard to make heads or tails of the function’s purpose. But after we run it through our loader:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://wrongbaud.github.io/assets/img/ghidra-loader/post-loader.png" alt="USB Annotation" /></p><p>Using the memory regions and the registers of interest, we’re able to see that this function is deciding which USB speed to use as well as setting up the central control registers. Is it perfect? No - of course not, but it does help streamline the process in some way.</p><p>There are also far more xrefs generated when using the loader, pointing to things like the various USB descriptors that the device uses during enumeration.</p><h2 id="conclusion">Conclusion</h2><p>With this post, we put together a simple Ghidra loader for the STM32F2 series microcontroller. While it is certainly not perfect, it was an excellent learning experience, and I hope to get some suggestions/corrections regarding how I implemented things. The loader is on my GH page, and I plan to update it as needed and start working on a more generic loader now that I’ve learned some of the basics. As always if you have any questions or comments, please feel free to reach out to me on <a href="https://twitter.com/wrongbaud">twitter</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/ghidra/'>ghidra</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/ghidra/" class="post-tag no-text-decoration" >ghidra</a> <a href="/tags/tools/" class="post-tag no-text-decoration" >tools</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Writing a GHIDRA Loader: STM32 Edition. - Wrongbaud's Blog&url=https://wrongbaud.github.io/posts/writing-a-ghidra-loader/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Writing a GHIDRA Loader: STM32 Edition. - Wrongbaud's Blog&u=https://wrongbaud.github.io/posts/writing-a-ghidra-loader/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Writing a GHIDRA Loader: STM32 Edition. - Wrongbaud's Blog&url=https://wrongbaud.github.io/posts/writing-a-ghidra-loader/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/ghidra-debugger/">A first look at Ghidra's Debugger - Game Boy Advance Edition</a><li><a href="/posts/Holiday-Teardown/">BasicFUN Series Part 4: I2C Sniffing, EEPROM Extraction and Parallel Flash Extraction</a><li><a href="/posts/BasicFUN-rom-analysis/">BasicFUN Series Part 2: Reverse Engineering Firmware / Reflashing SPI Flash</a><li><a href="/posts/MK-Teardown/">BasicFUN Series Part 3: Dumping Parallel Flash via I2C I/O Expanders</a><li><a href="/posts/stm-xbox-jtag/">Hardware Debugging for Reverse Engineers Part 1: SWD, OpenOCD and Xbox One Controllers</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/hardware/">hardware</a> <a class="post-tag" href="/tags/spi/">spi</a> <a class="post-tag" href="/tags/ghidra/">ghidra</a> <a class="post-tag" href="/tags/tools/">tools</a> <a class="post-tag" href="/tags/i2c/">i2c</a> <a class="post-tag" href="/tags/nand/">nand</a> <a class="post-tag" href="/tags/nes/">nes</a> <a class="post-tag" href="/tags/gba/">gba</a> <a class="post-tag" href="/tags/jtag/">jtag</a> <a class="post-tag" href="/tags/linux/">linux</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/hightec-tricore-linux-ghidra/"><div class="card-body"> <span class="timeago small" > Aug 4, 2019 <i class="unloaded">2019-08-04T08:20:10+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Tricore Basics: Using the Hightec Tricore Toolchain in Linux</h3><div class="text-muted small"><p> Background The Tricore CPU architecture is commonly found in automotive embedded systems, often running an RTOS or even just bare metal firmware. This post will go over setting up an entry level t...</p></div></div></a></div><div class="card"> <a href="/posts/Using-Buildroot-for-Reverse-Engineering/"><div class="card-body"> <span class="timeago small" > Sep 28, 2019 <i class="unloaded">2019-09-28T08:06:31+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Using Buildroot for Reverse Engineering</h3><div class="text-muted small"><p> Using Buildroot for Reverse Engineering Overview When reverse engineering an embedded system that is Linux based, one often wishes that they had an examplar system that could be virtualized, if o...</p></div></div></a></div><div class="card"> <a href="/posts/ghidra-training/"><div class="card-body"> <span class="timeago small" > Jul 30, 2020 <i class="unloaded">2020-07-30T08:06:31+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Introduction to Reverse Engineering with Ghidra: A Four Session Course</h3><div class="text-muted small"><p> Background / Catching Up Over the last few months, those of you who follow my ramblings here have probably noticed a serious lack of content (4 months!). When I started this project I wanted to tr...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/stm-xbox-jtag/" class="btn btn-outline-primary"><p>Hardware Debugging for Reverse Engineers Part 1: SWD, OpenOCD and Xbox One Controllers</p></a> <a href="/posts/jtag-hdd/" class="btn btn-outline-primary"><p>Hardware Debugging for Reverse Engineers Part 2: JTAG, SSDs and Firmware Extraction</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/wrongbaud">wrongbaud</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/hardware/">hardware</a> <a class="post-tag" href="/tags/spi/">spi</a> <a class="post-tag" href="/tags/ghidra/">ghidra</a> <a class="post-tag" href="/tags/tools/">tools</a> <a class="post-tag" href="/tags/i2c/">i2c</a> <a class="post-tag" href="/tags/nand/">nand</a> <a class="post-tag" href="/tags/nes/">nes</a> <a class="post-tag" href="/tags/gba/">gba</a> <a class="post-tag" href="/tags/jtag/">jtag</a> <a class="post-tag" href="/tags/linux/">linux</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://wrongbaud.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script> <script async src="https://www.googletagmanager.com/gtag/js?id="></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); </script>
