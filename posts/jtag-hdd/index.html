<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="theme" content="Chirpy v2.5.1"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Hardware Debugging for Reverse Engineers Part 2: JTAG, SSDs and Firmware Extraction" /><meta name="author" content="wrongbaud" /><meta property="og:locale" content="en_US" /><meta name="description" content="A blog focusing on hardware and software reverse engineering" /><meta property="og:description" content="A blog focusing on hardware and software reverse engineering" /><link rel="canonical" href="https://wrongbaud.github.io/posts/jtag-hdd/" /><meta property="og:url" content="https://wrongbaud.github.io/posts/jtag-hdd/" /><meta property="og:site_name" content="Wrongbaud’s Blog" /><meta property="og:image" content="https://wrongbaud.github.io/" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-04-02T08:06:31+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://wrongbaud.github.io/" /><meta property="twitter:title" content="Hardware Debugging for Reverse Engineers Part 2: JTAG, SSDs and Firmware Extraction" /><meta name="twitter:site" content="@wrongbaud" /><meta name="twitter:creator" content="@wrongbaud" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"A blog focusing on hardware and software reverse engineering","headline":"Hardware Debugging for Reverse Engineers Part 2: JTAG, SSDs and Firmware Extraction","dateModified":"2020-04-02T08:06:31+08:00","datePublished":"2020-04-02T08:06:31+08:00","@type":"BlogPosting","image":"https://wrongbaud.github.io/","url":"https://wrongbaud.github.io/posts/jtag-hdd/","mainEntityOfPage":{"@type":"WebPage","@id":"https://wrongbaud.github.io/posts/jtag-hdd/"},"author":{"@type":"Person","name":"wrongbaud"},"@context":"https://schema.org"}</script><title>Hardware Debugging for Reverse Engineers Part 2: JTAG, SSDs and Firmware Extraction | Wrongbaud's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="/assets/js/post.min.js"></script> <script defer src="/app.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/" alt="avatar"> <img src="https://i2.wp.com/wasistdas.co.uk/Owlsploitation/wp-content/uploads/2011/05/bubo2.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">Wrongbaud's Blog</a></div><div class="site-subtitle font-italic">Hardware / Software Reverse Engineering</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/wrongbaud" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/wrongbaud" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['wrongbaud','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Hardware Debugging for Reverse Engineers Part 2: JTAG, SSDs and Firmware Extraction</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Hardware Debugging for Reverse Engineers Part 2: JTAG, SSDs and Firmware Extraction</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Apr 2, 2020, 8:06 AM +0800" > Apr 2, 2020 <i class="unloaded">2020-04-02T08:06:31+08:00</i> </span> by <span class="author"> wrongbaud </span></div><div> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Nov 23, 2020, 7:40 AM -0500" > Nov 23, 2020 <i class="unloaded">2020-11-23T20:40:52+08:00</i> </span></div></div><div class="post-content"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="" class="post-preview-img"><h1 id="background">Background</h1><p>To follow up on my <a href="https://wrongbaud.github.io/posts/stm-xbox-jtag/">last post</a> about SWD and hardware debugging, I wanted to do a deep dive into JTAG from a reverse-engineering perspective. The previous post received a lot of great feedback and it seems that people are interested in this topic, so I wanted to continue the series and expand upon another hardware debugging mechanism. For those who are unfamiliar, JTAG is a hardware level debugging mechanism that many embedded CPUs utilize, with this post I hope to explain how to approach JTAG from a reverse engineers perspective and provide some practical examples along the way.</p><h2 id="goals">Goals</h2><p>With this post, I hope to do the following:</p><ol><li>Explain how JTAG works<li>Demonstrate how to discover and utilize a JTAG port/interface on an unknown target<li>Provide an overview of some of the current OSS tools that can be used to interact with a JTAG interface<li>Utilize JTAG to extract firmware and debug a target</ol><p>Also, before I give an overview, I wanted to point out a few great resources for learning about JTAG</p><ul><li><a href="https://github.com/cyphunk/JTAGenum/wiki/Embedded-Analysis#jtag">Cyphunk’s Embedded Analysis Page</a><li><a href="https://www.fpga4fun.com/JTAG.html">FPGA4Fun JTAG Overview</a><li><a href="https://pdfs.semanticscholar.org/69ac/07f94832ceb4d2344c9c2d2bc8fc04e68124.pdf?_ga=2.81325524.238759085.1584580795-2049975628.1584580795">Blackbox JTAG Reverse Engineering</a></ul><h2 id="jtag-overview">JTAG Overview</h2><p>JTAG is a hardware interface that was developed to assist developers and testers with low level debugging. JTAG was originally developed for testing integrated circuits and more specifically, sampling IO pins on a target under test. This type of debugging interface allows engineers to test connections on PCBs without needing the probe the physical pin itself. The JTAG interface is controlled via the state machine outlined below:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="http://openocd.org/doc-release/doxygen/jtag-state-machine-large.png" alt="JTAG State Machine" /></p><p>One of the important things to remember about JTAG at this level is that it involves two registers, the instruction register, and the data register. To utilize these registers, the proper states in the above state machine must be entered using the following interface signals:</p><div class="table-wrapper"><table><thead><tr><th>Line<th>Usage<tbody><tr><td>TMS<td>This pin is used to navigate and control the JTAG state machine<tr><td>TDI<td>Input pin, used to write data to the target<tr><td>TDO<td>Output pin, Used to read data back out from the target<tr><td>TCK<td>Used to determine when data is sampled for all inputs and outputs<tr><td>TRST (Optional)<td>This pin can be used to reset the state machine to the starting state</table></div><p>The state machine is navigated using the TMS and TCK lines, while data is written to or read from via TDI and TDO respectively. TMS is sampled on the rising edge of TCK, meaning that the TMS line must be asserted before TCK is toggled to navigate through the state machine. Data is then shifted into the instruction register (IR) or data register (DR) depending on the state of the JTAG state machine. When an operation is completed (or after the update DR/IR phase) the resulting data can be <em>shifted</em> out of DR by entering the <code class="language-plaintext highlighter-rouge">Shift-DR</code> state. With these primitives in place, manufacturers can implement whatever features they wish over JTAG.</p><p>The JTAG standard treats IR and DR as shift registers, and due to this, multiple targets can be daisy-chained together.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c9/Jtag_chain.svg/654px-Jtag_chain.svg.png" alt="JTAG Daisy Chain" /></p><p>In a nutshell, JTAG defines a state machine that is navigated with a minimum of 4 signals. With this state machine in place, end users can write and read from two shift registers, IR and DR.</p><h3 id="jtag-registers">JTAG Registers</h3><p>JTAG utilizes two main registers, the instruction register, and the data register. The instruction register is used to determine what function the JTAG controller is about to carry out such as a memory read, or memory write for example. The data register is then used as an additional input to the instruction register, for the previous example, they may be used to provide an address to read from or write to. These registers can vary in size based on their function.</p><p>To write to a register one would perform the following steps, we’ll use the IR as an example:</p><ol><li>Enter <code class="language-plaintext highlighter-rouge">Test Logic Reset</code> state (TLR) (This can be done by asserting the <code class="language-plaintext highlighter-rouge">TMS</code> line and cycling <code class="language-plaintext highlighter-rouge">CLK</code> 5 times)<li>Enter <code class="language-plaintext highlighter-rouge">Select IR Scan</code> state<li>Enter <code class="language-plaintext highlighter-rouge">Capture IR</code> state<li>Enter <code class="language-plaintext highlighter-rouge">Shift IR</code> – This is where we load the data into IR from TDI<li>Enter <code class="language-plaintext highlighter-rouge">Exit IR</code> state<li>Enter <code class="language-plaintext highlighter-rouge">Update IR</code> state – This stage “latches” the value into IR.</ol><p>Following this, if there were no data registers required, the operation would be performed, and the result (if any) would be loaded into the data register to be shifted out. However, many instructions require a data register to be filled out as well before operating. In that case, once the data register is written to and updated, the operation will be performed and the result can be shifted out of the data register.</p><p>Some instructions do not require the DR to be loaded, for example, if we had loaded the <code class="language-plaintext highlighter-rouge">IDCODE</code> instruction into IR (1110b), this would load the processor’s IDCODE value into the data register for us to then clock out and read it on <code class="language-plaintext highlighter-rouge">TDO</code>. To read the result out of <code class="language-plaintext highlighter-rouge">TDO</code>, one would navigate to the <code class="language-plaintext highlighter-rouge">Shift-DR</code> state, and clock in 32 bits on <code class="language-plaintext highlighter-rouge">TDI</code>, this would cause the data in the data register to be shifted out on the <code class="language-plaintext highlighter-rouge">TDO</code> line. See the image below for a visual representation of what would happen if one loaded the IR with the <code class="language-plaintext highlighter-rouge">IDCODE</code> instruction</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://www.embecosm.com/appnotes/ean5/images/jtag-architecture-2.png" alt="IDCODE Instruction" /></p><p>It’s important to remember, that <code class="language-plaintext highlighter-rouge">IR</code> and <code class="language-plaintext highlighter-rouge">DR</code> can be thought of as shift registers, meaning that when we update them with new values, the old values are then shifted out on <code class="language-plaintext highlighter-rouge">TDO</code>.</p><p>The JTAG standard defines the following instruction registers:</p><ul><li><code class="language-plaintext highlighter-rouge">BYPASS</code><ul><li>This instruction connects <code class="language-plaintext highlighter-rouge">TDI</code> and <code class="language-plaintext highlighter-rouge">TDO</code><li>In the <code class="language-plaintext highlighter-rouge">Shift DR</code> state, data is transferred from <code class="language-plaintext highlighter-rouge">TDI</code> to <code class="language-plaintext highlighter-rouge">TDO</code> with a delay of one <code class="language-plaintext highlighter-rouge">TCK</code> cycle<li>0 is loaded into the data register during the <code class="language-plaintext highlighter-rouge">Capture DR</code> state<li>This can be used to determine how many devices are in a scan chain</ul><li><code class="language-plaintext highlighter-rouge">IDCODE</code><ul><li>When loaded the Device Code Id Register is selected as the serial path between TDI and TDO<li>In the Capture-DR state, the 32-bit device ID code is loaded into this shift section<li>In the Shift-DR state, this data is shifted out, least significant bit first</ul><li><strong>Core JTAG Concepts</strong><ul><li>The state machine is navigated with 4 signals: <code class="language-plaintext highlighter-rouge">TCK</code>,<code class="language-plaintext highlighter-rouge">TMS</code>,<code class="language-plaintext highlighter-rouge">TDO</code> and <code class="language-plaintext highlighter-rouge">TDI</code><li><code class="language-plaintext highlighter-rouge">TDI</code> is used to provide input, <code class="language-plaintext highlighter-rouge">TDO</code> is used for output<li>Using this state machine data can be shifted into the IR (<code class="language-plaintext highlighter-rouge">Shift IR</code>) and the DR (<code class="language-plaintext highlighter-rouge">Shift DR</code>)<li>The instruction register (<code class="language-plaintext highlighter-rouge">IR</code>) can be thought of as a function, and the data register (<code class="language-plaintext highlighter-rouge">DR</code>) can be considered the argument to that function<li>As data is shifted into <code class="language-plaintext highlighter-rouge">DR</code> and <code class="language-plaintext highlighter-rouge">IR</code>, the previous contents are shifted out on <code class="language-plaintext highlighter-rouge">TDO</code><li>Once data is shifted into these registers, an operation can be performed (entirely dependent on host implementation aside from a few reserved instructions)<li>Data is <em>read</em> out of the target by shifting it onto <code class="language-plaintext highlighter-rouge">TDO</code> from the data register in the <code class="language-plaintext highlighter-rouge">Shift DR</code> state.</ul></ul><p>So now that we have gone over how JTAG works at a low level, we should talk about why we might care about it, and how this interface can grant access to useful features for reverse engineers. One of the most commonly used applications of the JTAG interface is hardware-level debugging (hence the title of this post). This is implemented by the chip manufacturer, and can vary from chip to chip, however, one of the most common implementations of hardware-level debugging for ARM targets is <a href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0314h/DDI0314H_coresight_components_trm.pdf">ARM’s CoreSight Debug Interface</a>. This is the same implementation that we <a href="https://wrongbaud.github.io/posts/stm-xbox-jtag/">communicated with over SWD in my last post</a>, only, in this case, the Debug Access Port is communicated with over JTAG. The specifics of the JTAG implementation can be <a href="https://static.docs.arm.com/ihi0031/c/IHI0031C_debug_interface_as.pdf">found here</a>. Luckily for us, some excellent OSS tools can be used to communicate with these ports - this post will focus on using OpenOCD.</p><p>OpenOCD takes care of utilizing the JTAG or SWD interface to grant the end-user various primitives that are provided by the debug interface exposed through the CoreSight DAP. The Coresight / DAP architecture is fairly complicated and too much to cover in this (already long) post, so I will potentially save that for another post</p><h2 id="jtag-for-reverse-engineers">JTAG for Reverse Engineers</h2><p>It’s extremely important to have a solid understanding of the protocol fundamentals when approaching something like this from a reverse engineer’s perspective. When reverse engineering hardware (or software) you want to have your ground truth covered since there are always infinite unknowns. These next few sections will go over how we can take advantage of our low-level knowledge of these protocols to assist us on our path to gaining access to hardware level debugging via JTAG. The first thing that we need to do is determine the pinout, and if the pins exposed allow access to the JTAG interface.</p><h3 id="determining-the-pinout">Determining the pinout</h3><p>JTAG signal lines are often grouped together, sometimes (if you’re extremely lucky!) you will see one of the following headers:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://elinux.org/images/4/48/Ti_arm_jtag.jpg" alt="JTAG Headers" /></p><p>If you find something like this however, it may not have the exact signal groupings, so we will discuss how to determine a pinout if one assumes it’s used for JTAG.</p><p>When reverse engineering something like this, you want to start with what you know. Since we know that most manufacturers at <em>least</em> implement <code class="language-plaintext highlighter-rouge">IDCODE</code> and <code class="language-plaintext highlighter-rouge">BYPASS</code> let’s talk about how we can take advantage of those two instructions.</p><p>If you have identified what you believe to be a potential JTAG header or pinout, but do not know the pins, we can use the behavior of these two registers to determine the pinout.</p><p>Since the <code class="language-plaintext highlighter-rouge">IDCODE</code> register is typically loaded as the default IR, one can test an assumed pinout by doing the following:</p><ol><li>Assign roles to potential output pins (TMS, TCK, etc)<li>Enter the <code class="language-plaintext highlighter-rouge">Test Logic Reset</code> state<li>Enter the <code class="language-plaintext highlighter-rouge">Select DR Scan</code>, <code class="language-plaintext highlighter-rouge">Capture DR</code>, <code class="language-plaintext highlighter-rouge">Shift DR</code><li>Clock 32 values on <code class="language-plaintext highlighter-rouge">TDI</code> and monitor <code class="language-plaintext highlighter-rouge">TDO</code> for a valid <code class="language-plaintext highlighter-rouge">IDCODE</code> value<li>Check the <code class="language-plaintext highlighter-rouge">IDCODE</code> value that you shifted out if it looks valid congratulations! Otherwise, reassign pins and repeat!</ol><p>In addition to taking advantage of the fact that the <code class="language-plaintext highlighter-rouge">IDCODE</code> register is often loaded into the IR by default, we can also utilize the fact that both the IR and DR behave as shift registers, so if we assume a common register length (32 bits often works) we can attempt to brute force the pinout by doing the following:</p><ol><li>Assign roles to potential output pins (TMS, TCK,etc)<li>Using these assumed values, enter the <code class="language-plaintext highlighter-rouge">Test Logic Reset</code> state<li>Enter the <code class="language-plaintext highlighter-rouge">Shift IR</code> state<li>Shift in a unique 32-bit value on <code class="language-plaintext highlighter-rouge">TDI</code><li>Continue to shift 1’s on <code class="language-plaintext highlighter-rouge">TDI</code> while monitoring for your unique pattern on TDO (be sure to do this as lease 32 times!).<li>If the pattern is discovered, congratulations! Otherwise, choose new assignments for the pins and repeat!</ol><p>Both of these methods are used by the previously mentioned <a href="https://github.com/cyphunk/JTAGenum/blob/master/JTAGenum.sh">JTAGEnum</a> script, as well as the <a href="http://www.grandideastudio.com/jtagulator/">JTAGULATOR</a>.</p><h3 id="determining-instruction-length">Determining Instruction Length</h3><p>Once you have determined the pinout of the target, then the real fun can begin. The next step is to then determine the length of the IR / DR. To do this, starting with IR, enter the <code class="language-plaintext highlighter-rouge">Shift IR</code> state and flood the chain with 1’s on <code class="language-plaintext highlighter-rouge">TDI</code>, using a large number like 1024 or 4096, and then clock in a 0. Once this has been done, simply continue to clock in 1’s on <code class="language-plaintext highlighter-rouge">TDI</code>, counting the number of clock cycles that it takes before a 0 appears on <code class="language-plaintext highlighter-rouge">TDO</code>. This will tell you the length of the IR. Once you have that, you can enter the <code class="language-plaintext highlighter-rouge">Shift DR</code> state and repeat the process to determine the state of the DR. This is something that <a href="http://urjtag.org/">urjtag</a> does very well.</p><h2 id="practical-example-samsung-m2-ssd">Practical Example: Samsung M.2 SSD</h2><p>The target for this post is going to be a Samsung M.2 SSD that I recently recovered from an older laptop. After looking at the PCB and spotting what could potentially be JTAG headers, I wanted to outline the process from start to finish.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://wrongbaud.github.io/assets/img/jtag-ssd/hdd.jpg" alt="PCB Target" /> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://wrongbaud.github.io/assets/img/jtag-ssd/PCB.png" alt="PCB Target" /></p><h3 id="practical-example-locating-jtag-headers--determining-pinout">Practical Example: Locating JTAG Headers / Determining Pinout</h3><p>As mentioned before JTAG lines are often grouped - so when looking at a new platform from a hardware perspective, looking for pin groupings greater than 5 is always a good start. Luckily for us on this target, there are 9 vias located along the outside of the PCB. Let’s start by examining the voltage levels of these pins with the drive in a normal operating state</p><div class="table-wrapper"><table><thead><tr><th>Pin<th>Voltage Level<th>Usage<tbody><tr><td>1<td>0.1 V<td>???<tr><td>2<td>1.8 V<td>???<tr><td>3<td>0.1 V<td>???<tr><td>4<td>0.1 V<td>???<tr><td>5<td>0.1 V<td>???<tr><td>6<td>0.1 V<td>???<tr><td>7<td>GND<td>GND<tr><td>8<td>1.8 V<td>???<tr><td>9<td>1.8 V<td>???</table></div><p>From a first pass - these voltage values don’t tell us anything, so what can we determine based on the information we have? First off, we have a GND which is an easy one to determine by using continuity mode on the multimeter and testing against something like a shield of the USB connector (while the target is unplugged of course!). Next, we have one line at 1.8V, typically one would expect this to be TMS as it is recommended to be held high in most documentation.</p><p>To determine the pinout, we will use a Raspberry Pi and the <a href="https://github.com/cyphunk/JTAGenum/blob/master/JTAGenum.sh">JTAGEnum</a> project. This script uses the aforementioned methods to attempt to identify a JTAG pinout. It is also important to note here that the logic levels are at 1.8V so we will need to use a logic level shifter if we’re going to interface to this target. JTAGEnum.sh uses the Raspberry Pi’s GPIO lines to actuate the target interface, in the shell script they include a map of the GPIO values which can be seen below:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre># define BCM pins (mapped directly to /sys/class/gpio/gpio${pin[N]})
# 5v 5v  g 14 15 18  g 23 24  g 25  8  7  1  g 12  g 16 20 21
# 3v  2  3  4  g 17 27 22 3v 10  9 11  g  0  5  6 13 19 26  g
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://www.bigmessowires.com/wp-content/uploads/2018/05/Raspberry-GPIO.jpg" alt="RPI" /></p><p>Using our table above, we will wire the following GPIOs to the unknown header:</p><div class="table-wrapper"><table><thead><tr><th>SSD Header Pin<th>RPi GPIO<tbody><tr><td>1<td>2<tr><td>2<td>3<tr><td>3<td>9<tr><td>4<td>10<tr><td>5<td>11<tr><td>6<td>25</table></div><p>In <code class="language-plaintext highlighter-rouge">JTAGenum.sh</code> we will modify the pins variable to be as follows:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>pins=(9 11 25 2 3 10)
pinnames=(pin1 pin2 pin3 pin4 pin5 pin6)
</pre></table></code></div></div><p>Now with the pins wired up, and the logic level shifter in place we can run <code class="language-plaintext highlighter-rouge">JTAGenum.sh</code>.</p><p>Running the script wired up as shown below yields a TON of results, the output can be seen [here]. Luckily for us, it properly identifies two possible configurations which can be seen below:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>FOUND!  ntrst:pin4 (RPi GPIO 2) tck:pin6 (RPi GPIO 10) tms:pin1 (RPi GPIO 9) tdo:pin3 (RPi GPIO 25) tdi:pin2 (RPi GPIO 11) IR length: 4
FOUND!  ntrst:pin5 (RPi GPIO 3) tck:pin6 (RPi GPIO 10) tms:pin1 (RPi GPIO 9) tdo:pin3 (RPi GPIO 25) tdi:pin2 (RPi GPIO 11) IR length: 4
</pre></table></code></div></div><p>Next, the script ran an ID scan. You might notice that a lot of results were generated for this, how do we filter through these? There are a few things that you can do to filter through the results, for example, we probably only have 1-2 devices on the scan chain (CPU and flash) so we can immediately ignore those that have more than 2-3 entries. Next, you can rule out those that have long (more than 4-5) sequences of 1’s or 0’s. Luckily in this list, there is an ID that I have seen before: <code class="language-plaintext highlighter-rouge">0x4ba00477</code> - this ID is for an ARM Cortex core and I’ve seen it before when attempting to get access to <a href="https://beagleboard.org/black">Beaglebone Black</a>.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>ntrst:pin4 tck:pin6 tms:pin1 tdo:pin3 tdi:pin2  devices: 1
0x4ba00477
ntrst:pin4 tck:pin6 tms:pin1 tdo:pin3 tdi:pin5  devices: 1
0x4ba00477
ntrst:pin5 tck:pin6 tms:pin1 tdo:pin3 tdi:pin2  devices: 1
0x4ba00477
ntrst:pin5 tck:pin6 tms:pin1 tdo:pin3 tdi:pin4  devices: 1
0x4ba00477
</pre></table></code></div></div><p>You’ll notice that with the IDCODE scan, the value for <code class="language-plaintext highlighter-rouge">TDI</code> varies, that is because this method does not rely on <code class="language-plaintext highlighter-rouge">TDI</code> at all so it is a guess.</p><p>Luckily some of these results line up nicely with the pattern scan, so we can now assume that we know the pinout of the JTAG interface!</p><div class="table-wrapper"><table><thead><tr><th>Pin<th>Voltage Level<th>Usage<tbody><tr><td>1<td>0.1<td>???<tr><td>2<td>1.8<td>???<tr><td>3<td>0.1<td>TMS<tr><td>4<td>0.1<td>CLK<tr><td>5<td>0.1<td>TDI<tr><td>6<td>0.1<td>TDO<tr><td>7<td>GND<td>GND<tr><td>8<td>1.8<td>???<tr><td>9<td>1.8<td>???</table></div><h3 id="practical-example-determining-instruction-length-with-urjtag">Practical Example: Determining Instruction Length with UrJtag</h3><p>While OpenOCD is excellent for interfacing with DAP controllers and connecting to debugging cores, the <a href="http://urjtag.org/">UrJTAG</a> project is great for interfacing with JTAG at a low level. We can use this to detect the various DR lengths with their useful <code class="language-plaintext highlighter-rouge">discover</code> command. This method uses the same principles mentioned earlier to select an <code class="language-plaintext highlighter-rouge">IR</code> then shift a large number of 1’s into <code class="language-plaintext highlighter-rouge">DR</code> followed by a 0, then clocking more 1’s until a 0 is read on TDO!</p><p>UrJTAG can use an rc file located at <code class="language-plaintext highlighter-rouge">~/.jtag/rc</code> mine is as follows</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>pi@raspberrypi:~ $ cat .jtag/rc 
cable gpio tck=10 tms=9 tdi=11 tdo=25
detect
discover
</pre></table></code></div></div><p>Below we can see the result of running UrJTAG with these commands:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre>pi@raspberrypi:~ $ sudo -E jtag 

UrJTAG 2019.12 #
Copyright (C) 2002, 2003 ETC s.r.o.
Copyright (C) 2007, 2008, 2009 Kolja Waschk and the respective authors

UrJTAG is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
There is no warranty for UrJTAG.

warning: UrJTAG may damage your hardware!
Type "quit" to exit, "help" for help.

Initializing GPIO JTAG Chain
IR length: 4
Chain length: 1
Device Id: 01001011101000000000010001110111 (0x4BA00477)
  Unknown manufacturer! (01000111011) (/usr/local/share/urjtag/MANUFACTURERS)
Detecting IR length ... 4
Detecting DR length for IR 1111 ... 1 &lt;-- This is BYPASS!
Detecting DR length for IR 0000 ... 1
Detecting DR length for IR 0001 ... 1
Detecting DR length for IR 0010 ... 1
Detecting DR length for IR 0011 ... 1
Detecting DR length for IR 0100 ... 1
Detecting DR length for IR 0101 ... 1
Detecting DR length for IR 0110 ... 1
Detecting DR length for IR 0111 ... 1
Detecting DR length for IR 1000 ... 35
Detecting DR length for IR 1001 ... 1
Detecting DR length for IR 1010 ... 35
Detecting DR length for IR 1011 ... 35
Detecting DR length for IR 1100 ... 1
Detecting DR length for IR 1101 ... 1
Detecting DR length for IR 1110 ... 32 &lt;-- This is IDCODE!
</pre></table></code></div></div><p>I wanted to highlight UrJTAG in this post because it is extremely useful when looking at a target with a completely unknown scan chain, or DAP architecture. Luckily for us, the <code class="language-plaintext highlighter-rouge">IDCODE</code> of this target tells us that it is ARM and we will likely be able to utilize the CoreSight DAP, to do this, we will use OpenOCD. If you are looking at a scan chain where you know <em>nothing</em> about it, I typically start with UrJtag just to get a map of all of the registers. The python bindings for UrJTAG also work quite well and can be used to interface with JTAG at a low level.</p><h2 id="jtag-debugging-via-openocd">JTAG Debugging via OpenOCD.</h2><p>Since we know the pinout of the JTAG interface on our target, we can now move onto using OpenOCD to communicate with it. I am choosing OpenOCD for this task because it has excellent debugging support for ARM MCUs, particularly the Cortex series which uses CoreSight. The first thing we’ll need to do is choose a hardware adapter, we will use the FT2232H breakout module.</p><h3 id="jtag-via-ft2232h">JTAG via FT2232H</h3><p>With the pinout understood, we can now attempt to talk to the DAP using OpenOCD. For this we will use an FT2232H adapter, for this post I am using a <a href="https://www.seeedstudio.com/FT2232H-USB-2-0-Hi-Speed-breakout-board-p-737.html">standard FT2232H breakout board</a>. These boards can be used to interract with multiple hardware level interfaces and have excellent software support. You may recall I’ve used them for things such as <a href="https://wrongbaud.github.io/posts/stm-xbox-jtag/">SWD</a> as well as <a href="https://wrongbaud.github.io/posts/Holiday-Teardown/">dumping SPI flash</a>. Using this board, along with a 3.3V to 1.8V logic level converyer we can wire it up to the target as follows:</p><div class="table-wrapper"><table><thead><tr><th>FT2232H Pin<th>Target<tbody><tr><td>CN2-7<td>TCK<tr><td>CN2-10<td>TDI<tr><td>CN2-9<td>TDO<tr><td>CN2-12<td>TMS</table></div><p>Next, we will write the outline of our config file, starting with the variables that we know about the target.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre>source [find target/swj-dp.tcl]

# This is using the name on the SoC
if { [info exists CHIPNAME] } {
  set _CHIPNAME $CHIPNAME
} else {
  set _CHIPNAME s4ln045x01
}

# This is the TAP ID that we discovered in the previous step
if { [info exists CPUTAPID] } {
  set _CPUTAPID $CPUTAPID
} else {
  set _CPUTAPID 0x4ba00477
}

# Set the speed of our adapter
adapter_khz 200
# We are indeed using JTAG
transport select jtag
# We don't have a SRST pin, only TRST it would seem
reset_config trst_only

# Here we create the JTAG TAP/DAP, defining the location and characteristics of our DAP
swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu
set _TARGETNAME $_CHIPNAME.cpu
</pre></table></code></div></div><p>When we run openocd with this config file, these are the results:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>wrongbaud@wubuntu:~/blog/samsung-jtag$ sudo openocd -f minimodule.cfg -f config.cfg 
Open On-Chip Debugger 0.10.0+dev-01040-ge7e681ac (2020-01-27-18:55)
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
Info : auto-selecting first available session transport "jtag". To override use 'transport select &lt;transport&gt;'.
Warn : Transport "jtag" was already selected
Info : clock speed 200 kHz
Info : JTAG tap: s4ln045x01.cpu tap/device found: 0x4ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x4)
Info : Listening on port 6666 for tcl connections
Info : Listening on port 4444 for telnet connections
Info : JTAG tap: s4ln045x01.cpu tap/device found: 0x4ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x4)
Warn : gdb services need one or more targets defined
</pre></table></code></div></div><p>Now let’s have a look at the DAP, and see if there is any more relevant information in there:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre><td class="rouge-code"><pre>&gt; dap info 0
DAP transaction stalled (WAIT) - slowing down
DAP transaction stalled (WAIT) - slowing down
AP ID register 0x24770002
        Type is MEM-AP APB
MEM-AP BASE 0x80000000
        ROM table in legacy format
                Component base address 0x80000000
                Peripheral ID 0x0000080000
                Designer is 0x080, &lt;invalid&gt;
                Part is 0x0, Unrecognized
                Component class is 0x1, ROM table
                MEMTYPE system memory not present: dedicated debug bus
        ROMTABLE[0x0] = 0x1003
                Component base address 0x80001000
                Peripheral ID 0x04008bbc14
                Designer is 0x4bb, ARM Ltd.
                Part is 0xc14, Cortex-R4 Debug (Debug Unit)
                Component class is 0x9, CoreSight component
                Type is 0x15, Debug Logic, Processor
        ROMTABLE[0x4] = 0x2003
                Component base address 0x80002000
                Peripheral ID 0x04008bbc14
                Designer is 0x4bb, ARM Ltd.
                Part is 0xc14, Cortex-R4 Debug (Debug Unit)
                Component class is 0x9, CoreSight component
                Type is 0x15, Debug Logic, Processor
        ROMTABLE[0x8] = 0x3003
                Component base address 0x80003000
                Peripheral ID 0x04008bbc14
                Designer is 0x4bb, ARM Ltd.
                Part is 0xc14, Cortex-R4 Debug (Debug Unit)
                Component class is 0x9, CoreSight component
                Type is 0x15, Debug Logic, Processor
        ROMTABLE[0xc] = 0x4003
                Component base address 0x80004000
                Invalid CID 0x00000000
        ROMTABLE[0x10] = 0x5003
                Component base address 0x80005000
                Invalid CID 0x00000000
        ROMTABLE[0x14] = 0x6003
                Component base address 0x80006000
                Invalid CID 0x00000000
        ROMTABLE[0x18] = 0x7003
                Component base address 0x80007000
                Invalid CID 0x00000000
        ROMTABLE[0x1c] = 0x8003
                Component base address 0x80008000
                Invalid CID 0x00000000
        ROMTABLE[0x20] = 0x9003
                Component base address 0x80009000
                Invalid CID 0x00000000
        ROMTABLE[0x24] = 0xa003
                Component base address 0x8000a000
                Invalid CID 0x00000000
        ROMTABLE[0x28] = 0xb003
                Component base address 0x8000b000
                Invalid CID 0x00000000
        ROMTABLE[0x2c] = 0xc003
                Component base address 0x8000c000
                Invalid CID 0x00000000
        ROMTABLE[0x30] = 0xd003
                Component base address 0x8000d000
                Invalid CID 0x00000000
        ROMTABLE[0x34] = 0xe003
                Component base address 0x8000e000
                Invalid CID 0x00000000
        ROMTABLE[0x38] = 0xf003
                Component base address 0x8000f000
                Invalid CID 0x00000000
        ROMTABLE[0x3c] = 0x0
                End of ROM table
</pre></table></code></div></div><p>The first thing that sticks out is that this is a Cortex R4, with this additional information we can create a target in the config file, which <em>should</em> grant access to the MEM-AP allowing for debugging. This can be done by adding the following line:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>target create $_TARGETNAME.1 cortex_r4 -endian $_ENDIAN -dap $_CHIPNAME.dap
</pre></table></code></div></div><p>With this additional line, we can try to halt the target via the <code class="language-plaintext highlighter-rouge">halt</code> command and read memory via <code class="language-plaintext highlighter-rouge">mdw</code> from the OpenOCD prompt:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>&gt; halt
MPIDR not in multiprocessor format
target halted in Thumb state due to debug-request, current mode: Supervisor
cpsr: 0x80000133 pc: 0x0001abfc
D-Cache: disabled, I-Cache: disabled
&gt; mdw 0x800000000 10
DAP transaction stalled (WAIT) - slowing down
0x800000000: eafffffe ea000005 ea000006 ea000006 ea00000b e320f000 ea00000e eafffffe
0x800000020: ea0000e3 eafffffe
</pre></table></code></div></div><p>Here we test stepping through the running firmware:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>&gt; halt
MPIDR not in multiprocessor format
target halted in ARM state due to debug-request, current mode: Supervisor
cpsr: 0x80000113 pc: 0x0000e10c
D-Cache: disabled, I-Cache: disabled
&gt; step
target halted in ARM state due to breakpoint, current mode: Supervisor
cpsr: 0x80000113 pc: 0x0000e110
D-Cache: disabled, I-Cache: disabled

</pre></table></code></div></div><p>Success! It appears to be working, and we can single-step through the firmware. Next, let’s use this capability to get some RAM dumps, <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0182n/CHDHAJCH.html">this page gives an overview of the memory model</a>, so we can use that as a reference. Memory can be dumped to a file with OpenOCD via the <code class="language-plaintext highlighter-rouge">dump_image</code> command.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>&gt; halt
MPIDR not in multiprocessor format
target halted in ARM state due to debug-request, current mode: Abort
cpsr: 0x200001d7 pc: 0x00000048
D-Cache: disabled, I-Cache: disabled
Data fault registers        DFSR: 00000008, DFAR: 9f7e3000
Instruction fault registers IFSR: 00000000, IFAR: 00000000
&gt; dump_image SDRAM.bin 0x20000000 0xA0000000
&gt; dump_image RAM.bin 0 0xFFFFFFF
</pre></table></code></div></div><p>Finally, let’s take these RAM dumps and load them into GHIDRA to see if they make sense:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://wrongbaud.github.io/assets/img/jtag-ssd/debug-xrefs.png" alt="Ghidra Refs" /></p><p>Excellent, we have some xrefs and the init code looks fairly sane. It also looks like there is some sort of debug menu that is presented over the UART, these are likely pins 8/9 on our pinout! Safe to say that this is a valid RAM dump, and with this, I will finish up this post.</p><h2 id="conclusion">Conclusion</h2><p>This was quite a long post - realistically it probably should have been broken up into 2-3 parts. With this post, we learned how JTAG functions at a low level, as well as how to approach JTAG as a reverse engineer. We were also able to get JTAG access to an undocumented target, extract memory, and single-step through the running firmware. There are lots of things left to do here, like determine if the flash chips themselves can be dumped via JTAG, RE the firmware to look for interesting ways to recover data from the drive (<a href="http://www2.futureware.at/~philipp/ssd/TheMissingManual.pdf">I recently discovered that lots of cool work has been done here already!</a>). As always, if you have any questions or comments, please feel free to reach out on <a href="https://twitter.com/wrongbaud">twitter</a>.</p><h2 id="refs">Refs</h2><p>I wanted to mention some awesome work that I found after going through all of this, both of these have already done a lot of what we did in this post today, albeit on slightly different drives. I’m sure that someone on twitter will let me know this so I wanted to link to some excellent previous work that was pointed out to me by some members of the OpenOCD community!</p><ul><li>https://github.com/thesourcerer8/SSDdiag<li>http://www2.futureware.at/~philipp/ssd/TheMissingManual.pdf</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/jtag/'>jtag</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/hardware/" class="post-tag no-text-decoration" >hardware</a> <a href="/tags/jtag/" class="post-tag no-text-decoration" >jtag</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Hardware Debugging for Reverse Engineers Part 2: JTAG, SSDs and Firmware Extraction - Wrongbaud's Blog&url=https://wrongbaud.github.io/posts/jtag-hdd/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Hardware Debugging for Reverse Engineers Part 2: JTAG, SSDs and Firmware Extraction - Wrongbaud's Blog&u=https://wrongbaud.github.io/posts/jtag-hdd/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Hardware Debugging for Reverse Engineers Part 2: JTAG, SSDs and Firmware Extraction - Wrongbaud's Blog&url=https://wrongbaud.github.io/posts/jtag-hdd/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/ghidra-debugger/">A first look at Ghidra's Debugger - Game Boy Advance Edition</a><li><a href="/posts/Holiday-Teardown/">BasicFUN Series Part 4: I2C Sniffing, EEPROM Extraction and Parallel Flash Extraction</a><li><a href="/posts/BasicFUN-rom-analysis/">BasicFUN Series Part 2: Reverse Engineering Firmware / Reflashing SPI Flash</a><li><a href="/posts/MK-Teardown/">BasicFUN Series Part 3: Dumping Parallel Flash via I2C I/O Expanders</a><li><a href="/posts/stm-xbox-jtag/">Hardware Debugging for Reverse Engineers Part 1: SWD, OpenOCD and Xbox One Controllers</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/hardware/">hardware</a> <a class="post-tag" href="/tags/spi/">spi</a> <a class="post-tag" href="/tags/ghidra/">ghidra</a> <a class="post-tag" href="/tags/tools/">tools</a> <a class="post-tag" href="/tags/i2c/">i2c</a> <a class="post-tag" href="/tags/nand/">nand</a> <a class="post-tag" href="/tags/nes/">nes</a> <a class="post-tag" href="/tags/gba/">gba</a> <a class="post-tag" href="/tags/jtag/">jtag</a> <a class="post-tag" href="/tags/linux/">linux</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/router-teardown/"><div class="card-body"> <span class="timeago small" > Oct 7, 2019 <i class="unloaded">2019-10-07T08:06:31+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Router Analysis Part 1: UART Discovery and SPI Flash Extraction</h3><div class="text-muted small"><p> Router Analysis Part 1: Hardware Teardown Overview In previous posts, we’ve gone over how to tear down Arcade cabinets containing SPI Flash as well as how to dissect the data that was extracted f...</p></div></div></a></div><div class="card"> <a href="/posts/MK-Teardown/"><div class="card-body"> <span class="timeago small" > Nov 26, 2019 <i class="unloaded">2019-11-26T08:06:31+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>BasicFUN Series Part 3: Dumping Parallel Flash via I2C I/O Expanders</h3><div class="text-muted small"><p> BasicFUN MK Teardown Part 1: Flash Extraction Background I noticed not too long ago that a new BasicFUN cabinet came out featuring one of my favorite childhood games: Mortal Kombat. This of cours...</p></div></div></a></div><div class="card"> <a href="/posts/Holiday-Teardown/"><div class="card-body"> <span class="timeago small" > Dec 30, 2019 <i class="unloaded">2019-12-30T08:06:31+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>BasicFUN Series Part 4: I2C Sniffing, EEPROM Extraction and Parallel Flash Extraction</h3><div class="text-muted small"><p> # Overview Over the holiday break, I received a few more random game platforms from friends and family who know how much I enjoy tearing into these things. While I didn’t find anything amazing or i...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/writing-a-ghidra-loader/" class="btn btn-outline-primary"><p>Writing a GHIDRA Loader: STM32 Edition.</p></a> <a href="/posts/ghidra-training/" class="btn btn-outline-primary"><p>Introduction to Reverse Engineering with Ghidra: A Four Session Course</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/wrongbaud">wrongbaud</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/hardware/">hardware</a> <a class="post-tag" href="/tags/spi/">spi</a> <a class="post-tag" href="/tags/ghidra/">ghidra</a> <a class="post-tag" href="/tags/tools/">tools</a> <a class="post-tag" href="/tags/i2c/">i2c</a> <a class="post-tag" href="/tags/nand/">nand</a> <a class="post-tag" href="/tags/nes/">nes</a> <a class="post-tag" href="/tags/gba/">gba</a> <a class="post-tag" href="/tags/jtag/">jtag</a> <a class="post-tag" href="/tags/linux/">linux</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://wrongbaud.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script> <script async src="https://www.googletagmanager.com/gtag/js?id="></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); </script>
